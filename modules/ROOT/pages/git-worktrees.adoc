= Git Worktrees
:keywords: git, software
:revdate: July 2023

image::guido-git-worktrees.png[]

Yes, git worktrees are not very well known, but they should be!
Worktrees allow you to checkout multiple branches independently.
They allow you to work on a branch and seamlessly switch to another branch without clobbering the changes you have made in the current branch.
Once you learn how to use them, it's hard to go back.

== What

Like most git concepts, worktrees are best explained with an example.
Imagine you are working on a new feature and a major production issue comes up - you need to quickly switch to a new hotfix branch, but you do not want to lose your changes.
Without git worktrees, you have 2 options:

. Commit all your changes to a temporary save commit
. Stash all your changes and then apply them later after making the hotfix

Neither of these options are ideal - you are saving changes that are not ready to be saved (including untracked files) then changing all the files in your project.
You also have to wait for your IDE to re-index the project.
It's like you are browsing the web with only 1 tab - you always have to navigate back to what you were working on.
What you really want is a clean context that you can work on without touching the context you are currently on (a new tab).
You could do this by re-cloning the repo to a separate folder. Then you do not have to do anything with your changes and you can work on the hotfix in your new clone.
Obviously that's not ideal either:

. You are wasting disk space
. Cloning takes time
. Your IDE has to index the project again
. Fetch operations have to be performed separately for all your repo copies

This is where git worktrees come in, they give you the benefits of having multiple copies of your repo without the disadvantages above.
Think of a worktree as a workspace in your repo; when you create a new worktree, a folder will be created that looks like your normal repo, but you don't actually have to re-clone it.
Going back to the web browser analogy, it's like you have more than 1 tab now! You can switch to a different tab (work tree) without changing what you are looking at in the current tab.
You can check out a branch in one work tree and then checkout a different branch in another work tree.
This is why they say work trees allow you to checkout more than one branch!

== How

Let's walk through a worktrees example.

Create a new git repo:

[,bash]
----
mkdir test-repo
cd test-repo
git init
----

Initializing a repo like this actually also creates a working tree. You can list working trees with 

[,bash]
----
git worktree list
----

.worktree list output
----
> git worktree list
/var/home/colby/scratch/test-repo  0000000 [main]
----

Let's add a file to our new repo and commit it:

[,bash]
----
touch test.txt
git add .
git commit -m "first"
----

Let's create a new worktree for a hotfix:

[,bash]
----
git worktree add ../hotfix
----

This will create a new directory that looks like a normal git repo.
If we run `git worktree list` again, we will see our new worktree:

.hotfix worktree
----
> git worktree list
/var/home/colby/scratch/test-repo  2bb7aa3 [main]
/var/home/colby/scratch/hotfix     2bb7aa3 [hotfix]
----

Let's navigate to it:

[,bash]
----
cd ../hotfix
----

You can make changes, commit, push, and even switch branches in this directory like it's a normal repo!
You can also navigate back to the main repo at anytime to make independent changes.

To remove a worktree, use the `worktree remove` command with the path to the worktree.


[,bash]
----
cd ../test-repo
git worktree remove ../hotfix
----

And that's all you need to know to get started with worktrees!
To summarize, the most common worktree commands you will use are:

git worktree list:: list worktrees
git worktree add <worktree>:: add a worktree at the specified path
git worktree remove <worktree>:: remove a worktree, deleting the directory it is stored in

== Add worktree variations

== Best practices/schemes

- Long lived: main, hotfix, feature
