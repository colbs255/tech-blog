= Volatile and Synchronized and Atomic, Oh My!
:keywords: java, atomic, cas, volatile, memory-visibility, synchronized

Java provides several constructs for mitigating the complexities of concurrency.
Their differences seem subtle but can have drastic effects on applications.
This article explains what these constructs are and when to use them.

== The Difficulties of Concurrency

Concurrent programming is difficult because of 2 problems: memory visibility and atomicity.

=== Memory Visibility

Consider this program:

[source,java]
----
import java.util.concurrent.TimeUnit;

public class Example {

    private static boolean stopRequested = false;

    public static void main(String[] args) throws InterruptedException {
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while (!stopRequested)
                i++;
        });

        backgroundThread.start();
        TimeUnit.SECONDS.sleep(1);
        stopRequested = true;
    }
}
----

If you try running it, it won't terminate.
Why? The java memory model does not guarantee that writes on a variable in one thread will appear in another thread.

=== Atomicity

Consider this program:

[source,java]
----
----

* Atomicity: if operations are interleaved, programs can behave in strange, unpredictable ways


== Solutions for concurrency
These constructs are different approaches to mitigating these problems:

* Volatile addresses the memory visibility problem: it tells java to not place the variable in a register and to instead grab the value from the main cache.
* Synchronized blocks have stronger semantics; they address the memory visibility problem but also address the atomicity problem by ensuring only 1 thread is running the sync block at a time.
* Atomic variables have volatile semantics with `get` and `set` but also support atomicity via compare and set (CAS) operations `compareAndSet`.

=== What is CAS?
CAS is considered non-locking synchronization.
They check the current value and only apply the change if the current value equals the expected value
CAS operations can be much more performant than traditional locks because they don't actually lock or have to reschedule threads.
The main disadvantage of CAS is it's harder to design algorithms around.
They are actually less performant when contention is very high (but still generally faster in most real world cases)

== Summary

|===
| Feature | Volatile | Sync | Atomic

| Memory Visibility
| Y
| Y
| Y

| Synchronized
| N
| Y
| Y
|===
