= Fluent Interface
:keywords: java, fluent, design, language, pattern
:revdate: April 2023

Fluent interfaces are easy to read.
Fluent interfaces are easy to use.
Fluent interfaces are natural.
That was not a fluent introduction to fluent interfaces;
here's a more fluent introduction: fluent interfaces read like natural language, making them easy to read and use.
Fluent interfaces are a powerful technique that promote expressive, maintainable code, and all developers should have them in their toolkit.

== What is a fluent interface?

Fluent interfaces are best explained with examples. Take a look at this https://junit.org/junit5/[JUnit] test:

.JUnit assertion
[source,java]
----
String result = operation();

assertTrue(result.length() > 10);
assertEquals(result.toLowerCase(), result);
assertTrue(result.contains("fish"));
----

Here's an equivalent test implemented with https://assertj.github.io/doc/[assertJ's] fluent interface:

.assertJ assertion
[source,java]
----
String result = operation();

assertThat(result)
    .hasSizeGreaterThan(10)
    .isLowerCase()
    .contains("fish");
----

The assertJ example:

* is easy to read. It reads like a sentence.
* is easy to write. The editor can auto-complete each method, guiding the developer.
* has 1 argument for each method. The developer does not have to remember which argument comes first.
* requires minimal code to add another assertion.

NOTE: Method chaining and fluent interfaces are not the same thing;
method chaining is one of the techniques used to create fluent interfaces.

== How do you implement a fluent interface?

Here is the most important point of the entire article: **a fluent interface is just a state machine.**.
Once you model the states and transitions, creating a fluent interface is straightforward.

=== Example: assertJ

Let's create our own assertJ assertions.
We need to implement the following methods:

* `assertThat`
* `hasSizeGreaterThan`
* `isLowerCase`
* `contains`

Each method moves us from one state to another state; they are our transitions. Let's draw our state machine:

.assertJ State Machine
image::assertJ-state-diagram.svg[]

This state machine is pretty simple because any of these methods can be called from the same state, so we only have one state.
The `AssertState` state can be modeled as an interface; the methods on the interface are possible transitions from the state.
Here's the interface for our `AssertState`:

.AssertState.java
[source,java]
----
interface AssertState {
    AssertState hasSizeGreaterThan(int expectedSize);
    AssertState isLowerCase();
    AssertState startsWith(String prefix);
    AssertState contains(String substring);
}
----

Now we just make a class that implements this interface:

.assertThat
[source,java]
----
class StringAsserter implements AssertState {

    private String actual;

    StringAsserter(String actual) {
        this.actual = actual;
    }

    @Override
    public AssertState hasSizeGreaterThan(int expectedSize) {
        if (actual.length() <= expectedSize) {
            throw new RuntimeException("...");
        }
        return this;
    }

    @Override
    public AssertState isLowerCase() {
        if (!actual.toLowerCase().equals(actual)) {
            throw new RuntimeException("...");
        }
        return this;
    }

    @Override
    public AssertState startsWith(String prefix) {
        if (!actual.startsWith(prefix)) {
            throw new RuntimeException("...");
        }
        return this;
    }

    @Override
    public AssertState contains(String substring) {
        if (!actual.contains(substring)) {
            throw new RuntimeException("...");
        }
        return this;
    }
}
----

That's the hard part! Now we just create a nice `assertThat` method for the client:

.assertThat entrypoint
[source,java]
----
class CustomAssertions {
    public static AssertState assertThat(String actual) {
        return new StringAsserter(actual);
    }
}
----

NOTE: The return type of the method is our interface `AssertState` NOT our implementation `StringAsserter`.
We don't want to expose our implementation to the client.

And that's it! We have our own fluent interface for string assertions!

=== Example: SQL Queries

Let's try a harder example: a fluent interface for basic SQL queries (inspired by the SQL code generator https://www.jooq.org[jOOQ]).
A SQL query might look like this:

.SQL Example
[source,sql]
----
SELECT PEOPLE.FirstName, PEOPLE.LastName
FROM PEOPLE
WHERE AGE > 25
AND Country = "USA"
ORDER BY LastName
----

We can express this query in java with a fluent interface like this:

.Fluent interface for SQL queries
[source,java]
----
String query = select(PEOPLE.FIRST_NAME, LAST_NAME)
    .from(PEOPLE)
    .where(PEOPLE.AGE.greaterThan(25))
    .and(PEOPLE.COUNTRY.eq("USA"))
    .orderBy(PEOPLE.LAST_NAME);
----

Let's draw our state machine:

.SQL query state machine
image::sql-query-state-diagram.svg[]

.SQL query state machine table
|===
| Current State | Transition | Output State

| StartState | select | SelectState

| SelectState | from | FromState

| FromState | where | WhereState
| | build | EndState
| | orderBy | OrderByState

| WhereState | and | WhereState
| | orderBy | OrderByState
| | build | EndState

| OrderByState | build | EndState
|===

.StartState.java
[source,java]
----
interface StartState {
    SelectState select(String column);
}
----

.SelectState.java
[source,java]
----
interface SelectState {
    FromState from(String table);
}
----

.FromState.java
[source,java]
----
interface FromState {
    WhereState where(String clause);
    OrderByState orderBy(String orderBy);
    String build();
}
----

.WhereState.java
[source,java]
----
interface WhereState {
    WhereState and(String clause);
    OrderByState orderBy(String orderBy);
    String build();
}
----

.OrderByState.java
[source,java]
----
interface OrderByState {
    String build();
}
----

If you've made it this far, congrats!
It's smooth sailing from here!
Let's create a new class that implements all of these interfaces:

.QueryBuilder.java
[source,java]
----
class QueryBuilder implements StartState, SelectState, FromState, WhereState, OrderByState {

}
----

Now add the properties that we need:
.QueryBuilder.java
[source,java]
----
class QueryBuilder implements StartState, SelectState, FromState, WhereState, OrderByState {

    List<String> columns;
    String table;
    List<String> conditions = new ArrayList<>();
    String orderByColumn;
}
----

Then implement our interface methods.
Notice how the implementation is very similar to the builder pattern.
The main difference is each method returns a different type (the next state) instead of the same `QueryBuilder`.

.QueryBuilder.java
[source,java]
----
class QueryBuilder implements StartState, SelectState, FromState, WhereState, OrderByState {

    List<String> columns;
    String table;
    List<String> conditions = new ArrayList<>();
    String orderByColumn;

    @Override
    public SelectState select(String column) {
        columns = List.of(column);
        return this;
    }

    @Override
    public FromState from(String table) {
        this.table = table;
        return this;
    }

    @Override
    public WhereState where(String clause) {
        this.conditions.add(clause);
        return this;
    }

    @Override
    public WhereState and(String clause) {
        this.conditions.add(clause);
        return this;
    }

    @Override
    public OrderByState orderBy(String orderBy) {
        this.orderByColumn = orderBy;
        return this;
    }

    @Override
    public String build() {
        String selectComponent = "SELECT " + String.join("," , this.columns)
                + " FROM " + table;

        String whereComponent = conditions.isEmpty()
                ? ""
                : " WHERE " + String.join(" AND ", conditions);

        String orderByComponent = orderByColumn == null
                ? ""
                : " ORDER BY " + orderByColumn;

        return selectComponent + whereComponent + orderByComponent;
    }
}
----

=== Fluent Interface cookbook

Let's summarize our steps for creating a fluent interface:

. Model your fluent interface as a state machine.
. Convert your state machine to a set of interfaces.
    .. Each state is an interface.
    .. Each transition is a method where the current state is the interface the transition belongs to and the next state is the return type of the method.
. Create a class with all the fields you need.
. Implement all your interfaces in your class. Each method mutates something in your class and then returns `this`.
    .. Each method can return a different interface, but we can always return `this` because it implements all of our interfaces.

== When should you use fluent interfaces?

.Pros
* easy to read/write
* less to import
* reads in natural way

.Cons
* harder to implement, more code to implement
* As you can see, actually designing a fluent interface is not easy.
