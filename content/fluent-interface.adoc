= Fluent Interface
:keywords: java, fluent, design, language, pattern

A fluent interface is a style that promotes readability and reduces boilerplate for the user.
Developers should have this style in their toolkit since it encourages expressive code that is **both** easy to read and write.

== What is a fluent interface?

Fluent interfaces are best explained with examples. Take a look at this https://junit.org/junit5/[JUnit] test:

.JUnit assertion
[source,java]
----
String result = operation();

assertTrue(result.length() > 10);
assertEquals(result.toLowerCase(), result);
assertTrue(result.contains("fish"));
----

Here's an equivalent test implemented with the functional interface of https://assertj.github.io/doc/[assertJ]:

.assertJ assertions
[source,java]
----
String result = operation();

assertThat(result)
    .hasSizeGreaterThan(10)
    .isLowerCase()
    .contains("fish");
----

The assertJ example is...

* easier to read (even if you haven't seen assertJ syntax before)
* easier to write
* can easily be modified by adding another clause
* do not have to remember the args order

WARNING: Method chaining and fluent interfaces are not the same thing;
method chaining is a technique that is used to create fluent interfaces.

== How do you implement it?

=== Construct your state machine

=== Example: assertJ

We have 4 methods that need to be implemented:

* `assertThat`
* `hasSizeGreaterThan`
* `isLowerCase`
* `contains`

Let's draw our state machine:

.assertJ State Machine
image::assertJ-state-diagram.svg[]

This state machine is pretty simple because any of these methods can be called from the same state, so we only have to implement one state.
Here's our state interface:

[source,java]
----
interface AssertState {
    AssertState hasSizeGreaterThan(int size);
    AssertState isLowerCase();
    AssertState startsWith(String s);
    AssertState contains(String s);
}
----

And here's our entry point into our fluent interface assertThat:

[source,java]
----
public static AssertState assertThat(String s) {
    return new AssertState() {
        @Override
        public AssertState hasSizeGreaterThan(int size) {
            if (s.length() <= size) {
                throw new RuntimeException("...");
            }
            return this;
        }

        @Override
        public AssertState isLowerCase() {
            if (!s.toLowerCase().equals(s)) {
                throw new RuntimeException("...");
            }
            return this;
        }

        @Override
        public AssertState contains(String other) {
            if (!s.contains(other)) {
                throw new RuntimeException("...");
            }
            return this;
        }
    };
}
----

Now we have our own fluent interface for validating strings in tests!

=== Example: SQL Queries

Let's create a fluent interface for basic SQL queries (inspired by the SQL code generator https://www.jooq.org[jOOQ]).
A SQL query might look like:

[source,sql]
----
SELECT PEOPLE.FirstName, PEOPLE.LastName
FROM PEOPLE
WHERE AGE > 25
AND Country = "USA"
ORDER BY LastName
----

We can express this query in java with a functional interface like this:

[source,java]
----
String query = select(PEOPLE.FIRST_NAME, LAST_NAME)
    .from(PEOPLE)
    .where(PEOPLE.AGE.greaterThan(25))
    .and(PEOPLE.COUNTRY.eq("USA"))
    .orderBy(PEOPLE.LAST_NAME);
----


== When should you use it?

.Pros
* easy to read/write
* less to import
* reads in an awkward way

.Cons
* harder to implement, more code to implement
* reading the implementation of a fluent interface is not easy
