= Fluent Interface
:keywords: java, fluent, design, language, pattern

A fluent interface is an interface style that promotes readability and is easy for the client to write.
Developers should have this style in their toolkit since it encourages expressive code that is **both** easy to read and write.

== What is a fluent interface?

Fluent interfaces are best explained with examples. Take a look at this https://junit.org/junit5/[JUnit] test:

.JUnit assertion
[source,java]
----
String result = operation();

assertTrue(result.length() > 10);
assertEquals(result.toLowerCase(), result);
assertTrue(result.contains("fish"));
----

Here's an equivalent test implemented with https://assertj.github.io/doc/[assertJ's] fluent interface:

.assertJ assertions
[source,java]
----
String result = operation();

assertThat(result)
    .hasSizeGreaterThan(10)
    .isLowerCase()
    .contains("fish");
----

The assertJ example is...

* easier to read (even if you haven't seen assertJ syntax before)
* easier to write: lowers cognitive complexity, editor can autocomplete arguments
* can easily be modified by adding another clause
* do not have to remember the args order

WARNING: Method chaining and fluent interfaces are not the same thing;
method chaining is a technique that is used to create fluent interfaces.

== How do you implement it?

This is the most important clause in the entire article: **a fluent interface is just a state machine**.
Once you figure out the states and transitions, creating a fluent interface is actually straightforward.

=== Construct your state machine

=== Example: assertJ

We have 4 methods that need to be implemented:

* `assertThat`
* `hasSizeGreaterThan`
* `isLowerCase`
* `contains`

Let's draw our state machine:

.assertJ State Machine
image::assertJ-state-diagram.svg[]

This state machine is pretty simple because any of these methods can be called from the same state, so we only have to implement one state.
Here's our state interface:

.AssertState interface
[source,java]
----
interface AssertState {
    AssertState hasSizeGreaterThan(int size);
    AssertState isLowerCase();
    AssertState startsWith(String s);
    AssertState contains(String s);
}
----

And here's our entry point into our fluent interface assertThat:

.assertThat
[source,java]
----
public static AssertState assertThat(String s) {
    return new AssertState() {
        @Override
        public AssertState hasSizeGreaterThan(int size) {
            if (s.length() <= size) {
                throw new RuntimeException("...");
            }
            return this;
        }

        @Override
        public AssertState isLowerCase() {
            if (!s.toLowerCase().equals(s)) {
                throw new RuntimeException("...");
            }
            return this;
        }

        @Override
        public AssertState contains(String other) {
            if (!s.contains(other)) {
                throw new RuntimeException("...");
            }
            return this;
        }
    };
}
----

Now we have our own fluent interface for validating strings in tests!

=== Example: SQL Queries

Let's create a fluent interface for basic SQL queries (inspired by the SQL code generator https://www.jooq.org[jOOQ]).
A SQL query might look like:

.SQL Example
[source,sql]
----
SELECT PEOPLE.FirstName, PEOPLE.LastName
FROM PEOPLE
WHERE AGE > 25
AND Country = "USA"
ORDER BY LastName
----

We can express this query in java with a fluent interface like this:

.Fluent interface for SQL queries
[source,java]
----
String query = select(PEOPLE.FIRST_NAME, LAST_NAME)
    .from(PEOPLE)
    .where(PEOPLE.AGE.greaterThan(25))
    .and(PEOPLE.COUNTRY.eq("USA"))
    .orderBy(PEOPLE.LAST_NAME);
----

Let's draw our state machine:

.SQL query state machine
image::sql-query-state-diagram.svg[]

.SQL query state machine table
|===
| Current State | Transition | Output State

| StartState | select | SelectState

| SelectState | from | FromState

| FromState | where | WhereState
| | build | EndState
| | orderBy | OrderByState

| WhereState | and | WhereState
| | orderBy | OrderByState
| | build | EndState

| OrderByState | build | EndState
|===

.StartState.java
[source,java]
----
interface StartState {
    SelectState select(String column);
}
----

.SelectState.java
[source,java]
----
interface SelectState {
    FromState from(String table);
}
----

.FromState.java
[source,java]
----
interface FromState {
    WhereState where(String clause);
    OrderByState orderBy(String orderBy);
    String build();
}
----

.WhereState.java
[source,java]
----
interface WhereState {
    WhereState and(String clause);
    OrderByState orderBy(String orderBy);
    String build();
}
----

.OrderByState.java
[source,java]
----
interface OrderByState {
    String build();
}
----

If you've made it this far, congrats! It's smooth sailing from here! Create a new class that implements all of these interfaces:

.QueryBuilder.java
[source,java]
----
class QueryBuilder implements StartState, SelectState, FromState, WhereState, OrderByState {

}
----

Add the properties that we need:
.QueryBuilder.java
[source,java]
----
class QueryBuilder implements StartState, SelectState, FromState, WhereState, OrderByState {

    List<String> columns;
    String table;
    List<String> conditions = new ArrayList<>();
    String orderByColumn;
}
----

Then implement our interface methods.
Notice how the implementation is very similar to the builder pattern.
The main difference is each method returns a different interface instead of `QueryBuilder`.

.QueryBuilder.java
[source,java]
----
class QueryBuilder implements StartState, SelectState, FromState, WhereState, OrderByState {

    List<String> columns;
    String table;
    List<String> conditions = new ArrayList<>();
    String orderByColumn;

    @Override
    public SelectState select(String column) {
        columns = List.of(column);
        return this;
    }

    @Override
    public FromState from(String table) {
        this.table = table;
        return this;
    }

    @Override
    public WhereState where(String clause) {
        this.conditions.add(clause);
        return this;
    }

    @Override
    public WhereState and(String clause) {
        this.conditions.add(clause);
        return this;
    }

    @Override
    public OrderByState orderBy(String orderBy) {
        this.orderByColumn = orderBy;
        return this;
    }

    @Override
    public String build() {
        String selectComponent = "SELECT " + String.join("," , this.columns)
                + " FROM " + table;

        String whereComponent = conditions.isEmpty()
                ? ""
                : " WHERE " + String.join(" AND ", conditions);

        String orderByComponent = orderByColumn == null
                ? ""
                : " ORDER BY " + orderByColumn;

        return selectComponent + whereComponent + orderByComponent;
    }
}
----

== When should you use it?

.Pros
* easy to read/write
* less to import
* reads in an awkward way

.Cons
* harder to implement, more code to implement
* As you can see, actually designing a fluent interface is not easy.
