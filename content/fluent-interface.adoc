= Fluent Interface
:keywords: java, fluent, design, language, pattern

A fluent interface is a style that promotes readability and reduces boilerplate for the user.
Developers should have this style in their toolkit since it encourages expressive code that is **both** easy to read and write.

== What is a fluent interface?

Fluent interfaces are best explained with examples. Take a look at this https://junit.org/junit5/[JUnit] test:

.JUnit assertion
[source,java]
----
String result = operation();

assertTrue(result.length() > 10);
assertEquals(result.toLowerCase(), result);
assertTrue(result.startsWith("nemo"));
assertTrue(result.contains("fish"));
----

Here's an equivalent test implemented with the functional interface of https://assertj.github.io/doc/[assertJ]:

.assertJ assertions
[source,java]
----
String result = operation();

assertThat(result)
    .hasSizeGreaterThan(10)
    .isLowerCase()
    .startsWith("nemo")
    .contains("fish");
----

The assertJ example is...

* easier to read (even if you haven't seen assertJ syntax before)
* easier to write
* can easily be modified by adding another clause

WARNING: Method chaining and fluent interfaces are not the same thing;
method chaining is a technique that is used to create fluent interfaces.

== How do you implement it?

=== Construct your state machine

=== Example: assertJ

We have 5 methods that need to be implemented:

* `assertThat`
* `hasSizeGreaterThan`
* `isLowerCase`
* `startsWith`
* `contains`

Let's make draw our state machine:

.assertJ State Machine
image::assertJ-state-diagram.svg[]

=== Example: SQL Queries

Let's create a fluent interface for basic database queries (inspired by the SQL code generator https://www.jooq.org[jOOQ]).
A SQL query might look like:

[source,sql]
----
SELECT PEOPLE.FirstName, PEOPLE.LastName
FROM PEOPLE
WHERE AGE > 25
AND Country = "USA"
ORDER BY LastName
----

We can express this query in java with a functional interface like this:

[source,java]
----
String query = select(PEOPLE.FIRST_NAME, LAST_NAME)
    .from(PEOPLE)
    .where(PEOPLE.AGE.greaterThan(25))
    .and(PEOPLE.COUNTRY.eq("USA"))
    .orderBy(PEOPLE.LAST_NAME);
----


== When should you use it?

.Pros
* easy to read/write
* less to import
* reads in an awkward way

.Cons
* harder to implement, more code to implement
* reading the implementation of a fluent interface is not easy
